# Implementation Log: Step 3.2 - Common Library Foundation

**Implementation Date**: November 8, 2025  
**Last Updated**: November 8, 2025  
**Implementation Phase**: Phase 1 - Project Structure Initialization  
**Status**: ✅ Complete

---

## Overview

This log documents the completion of Step 3.2 from the Angry Birdman
implementation plan: Common Library Foundation. This step creates a shared
TypeScript library (`@angrybirdman/common`) containing type definitions,
validation schemas, business logic functions, and constants used across frontend
and backend workspaces.

## Objectives

1. Create comprehensive TypeScript type definitions matching the Prisma schema
2. Implement Zod validation schemas for runtime data validation
3. Build utility functions for calculations (ratios, margins, rankings)
4. Create date formatting utilities (Battle ID, Month ID, Year ID handling)
5. Define application constants (action codes, validation limits)
6. Write comprehensive unit tests for all functionality
7. Ensure proper library compilation and export structure

## Deliverables

### 1. Type Definitions (`common/src/types/index.ts`)

**Size**: 398 lines  
**Purpose**: TypeScript interfaces matching all Prisma models

**Key Types Implemented**:

- Core entities: `Clan`, `User`, `RosterMember`, `ClanBattle`
- Battle stats: `ClanBattlePlayerStats`, `ClanBattleNonplayerStats`
- Aggregated stats: `MonthlyClanPerformance`, `MonthlyIndividualPerformance`,
  `YearlyClanPerformance`, `YearlyIndividualPerformance`
- Action codes: `ActionCode` entity
- Create/Update variants: `CreateClan`, `UpdateClan`, etc.
- API utilities: `PaginatedResponse<T>`, `ApiError`

**Design Decisions**:

- All dates as `Date` objects (converted from Prisma's DateTime)
- Optional fields marked with `?` for partial updates
- Omitted internal fields (`id`, timestamps) from Create types
- Generic `PaginatedResponse<T>` for consistent API pagination

### 2. Validation Schemas (`common/src/schemas/index.ts`)

**Size**: 531 lines  
**Purpose**: Zod schemas for runtime validation

**Schema Categories**:

1. **Primitive schemas**: `actionCode`, `battleResult`, `positiveInteger`,
   `flockPower`, `ratio`, `percentage`
2. **ID schemas**: `battleId` (YYYYMMDD), `monthId` (YYYYMM), `yearId` (YYYY)
3. **Entity schemas**: Validation for all 11 Prisma models
4. **Create/Update schemas**: Input validation for API mutations
5. **API request schemas**: `paginationParams`, `sortParams`, `dateRangeParams`

**Key Validations**:

- FP range: 1-5000 (as per spec Section 6)
- Ratios: 0-1000 (0 to 100.0 when displayed)
- Percentages: 0-100
- Battle IDs: Exactly 8 digits (YYYYMMDD)
- Month IDs: Exactly 6 digits (YYYYMM)
- Year IDs: Exactly 4 digits (YYYY)

### 3. Calculation Utilities (`common/src/utils/calculations.ts`)

**Size**: 246 lines  
**Purpose**: Implements all formulas from spec Section 7

**Functions Implemented** (18 total):

1. `calculateBattleResult(score, opponentScore)` - Returns WIN(1), LOSS(-1), or
   TIE(0)
2. `calculateClanRatio(score, baselineFp)` - Official clan ratio using baseline
   FP
3. `calculateAverageRatio(score, totalFp)` - Average ratio using actual FPs
4. `calculatePlayerRatio(score, fp)` - Individual player performance
5. `calculateProjectedScore(score, nonplayingFpRatio)` - What score would be if
   all played
6. `calculateMarginRatio(score, opponentScore)` - Win/loss margin percentage
7. `calculateFpMargin(clanFp, opponentFp)` - FP advantage/disadvantage
8. `calculateNonplayingFpRatio(totalFp, playingFp, reserveFp)` - % FP didn't
   play (excluding reserves)
9. `calculateReserveFpRatio(totalFp, reserveFp)` - % FP in reserve
10. `calculateRatioRanks(playerRatios)` - Rank players by performance
11. `calculateAverage(values)` - Mean of array
12. `calculateSum(values)` - Sum of array
13. `calculateCount(values, predicate)` - Count matching condition
14. `calculateMin(values)` - Minimum value
15. `calculateMax(values)` - Maximum value
16. `isValidRatio(ratio)` - Validation helper
17. `isValidPercentage(percentage)` - Validation helper
18. `roundToDecimalPlaces(value, places)` - Rounding utility

**Formula Validation**:

- All formulas verified against `specs/high-level-spec.md` Section 7
- Ratio multiplier: 10 (produces values like 125.5 for display as "12.55")
- Percentage multiplier: 100
- Battle result constants: WIN=1, LOSS=-1, TIE=0

### 4. Date Formatting Utilities (`common/src/utils/date-formatting.ts`)

**Size**: 281 lines (after regex validation fix)  
**Purpose**: Battle/Month/Year ID generation, parsing, and validation

**Key Functions**:

- **Generation**: `generateBattleId(date)`, `generateMonthId(date)`,
  `generateYearId(date)`
- **Parsing**: `parseBattleId(id)`, `parseMonthId(id)`, `parseYearId(id)`
- **Validation**: `validateBattleId(id)`, `validateMonthId(id)`,
  `validateYearId(id)`
- **Range helpers**: `getBattleIdsForMonth(monthId)`,
  `getMonthIdsForYear(yearId)`
- **Display**: `formatBattleDate(battleId)`, `formatMonthDate(monthId)`,
  `formatYearDate(yearId)`
- **Extraction**: `extractMonthIdFromBattleId(battleId)`,
  `extractYearIdFromBattleId(battleId)`, etc.

**ID Formats**:

- Battle ID: `YYYYMMDD` (e.g., "20250315")
- Month ID: `YYYYMM` (e.g., "202503")
- Year ID: `YYYY` (e.g., "2025")

**Bug Fixed During Testing**:

- Initial `parseYearId()` used `parseInt('202A')` which returns 202 instead of
  throwing
- Added regex validation `/^\d+$/` to ensure all characters are digits before
  parsing

### 5. Constants (`common/src/constants/index.ts`)

**Size**: 127 lines  
**Purpose**: Application-wide constants

**Constants Defined**:

```typescript
ACTION_CODES = {
  HOLD: 'HOLD', // Keep player active
  WARN: 'WARN', // Warning for underperformance
  KICK: 'KICK', // Remove from clan
  RESERVE: 'RESERVE', // Move to reserve (suppress FP)
  PASS: 'PASS', // No action needed
};

BATTLE_RESULTS = {
  WIN: 1,
  LOSS: -1,
  TIE: 0,
};

// Validation limits
MIN_FLOCK_POWER = 1;
MAX_FLOCK_POWER = 5000;
MIN_RATIO = 0;
MAX_RATIO = 1000;
MIN_PERCENTAGE = 0;
MAX_PERCENTAGE = 100;
MIN_BATTLES_FOR_STATS = 3;

// ID formats
BATTLE_ID_LENGTH = 8; // YYYYMMDD
MONTH_ID_LENGTH = 6; // YYYYMM
YEAR_ID_LENGTH = 4; // YYYY

// Calculation multipliers
RATIO_MULTIPLIER = 10; // (score/fp) * 10
PERCENTAGE_MULTIPLIER = 100;
```

### 6. Test Suite

**Total Tests**: 105 tests across 3 files  
**Test Coverage**: 100% pass rate  
**Test Execution Time**: ~670ms

#### Calculation Tests (`tests/calculations.test.ts`)

**Tests**: 34  
**Coverage**:

- Battle result calculations (3 tests)
- Ratio calculations (5 tests)
- Projected score (2 tests)
- Margin calculations (4 tests)
- Non-playing FP ratios (4 tests)
- Ratio ranking (4 tests)
- Aggregation functions (4 tests)
- Validation helpers (4 tests)
- Rounding utilities (3 tests)
- Full battle integration test (1 test)

#### Date Formatting Tests (`tests/date-formatting.test.ts`)

**Tests**: 38  
**Coverage**:

- Battle ID generation/parsing (7 tests)
- Month ID generation/parsing (5 tests)
- Year ID generation/parsing (5 tests)
- ID validation (6 tests)
- Date range helpers (4 tests)
- ID extraction utilities (4 tests)
- Display formatting (4 tests)
- Round-trip conversions (3 tests)

#### Schema Validation Tests (`tests/schemas.test.ts`)

**Tests**: 33  
**Coverage**:

- Primitive type schemas (5 test groups)
- ID format schemas (3 test groups)
- Entity create schemas (5 test groups)
- Aggregated statistics schemas (1 test group)
- API request schemas (1 test group)
- Complex integration scenarios (1 test group)

### 7. Configuration Files

#### Vitest Configuration (`vitest.config.ts`)

**Purpose**: Test runner configuration  
**Key Settings**:

- Include: `tests/**/*.test.ts`
- Exclude: `dist/`, `node_modules/`
- Environment: Node.js
- Globals: Enabled for cleaner test syntax

**Why Created**: Initial test runs picked up both source `.ts` files and
compiled `.js` files in `dist/`, causing duplicate test execution and false
failures. Configuration ensures only source tests run.

#### TypeScript Configuration (`tsconfig.json`)

**Updates Made**:

- `rootDir: "./src"` - Only compile source files
- `exclude: ["tests"]` - Don't include tests in build output
- Maintains declaration file generation for type exports

## Implementation Process

### Phase 1: Planning & Research

1. Reviewed `specs/implementation-plan.md` Section 3.2 requirements
2. Analyzed `specs/high-level-spec.md` Sections 6 (Data Model) and 7
   (Calculations)
3. Examined `database/prisma/schema.prisma` for type alignment
4. Studied previous log format (`3.1 - Implementation Log.md`)

### Phase 2: Type System Foundation

1. Created `types/index.ts` with all 11 Prisma entity interfaces
2. Added Create/Update type variants for API inputs
3. Implemented utility types (`PaginatedResponse`, `ApiError`)
4. Ensured date handling consistency (all `Date` objects)

### Phase 3: Validation Layer

1. Built primitive Zod schemas (integers, ratios, percentages)
2. Created ID format schemas with exact length validation
3. Implemented entity schemas matching Prisma constraints
4. Added Create/Update schemas for API validation
5. Built API helper schemas (pagination, sorting, date ranges)

### Phase 4: Business Logic

1. Implemented all 18 calculation functions per spec formulas
2. Created comprehensive date utilities for ID handling
3. Added aggregation helpers (sum, average, min, max, count)
4. Implemented validation and rounding utilities

### Phase 5: Testing & Validation

1. Wrote 105 comprehensive unit tests
2. Initial test run: 205 tests (duplicate .js/.ts execution)
3. Created `vitest.config.ts` to fix duplicate execution
4. Fixed bug in `parseYearId()` - added regex validation
5. Final result: 105 tests, 100% pass rate

### Phase 6: Build Verification

1. Ran `npm run build` - successful TypeScript compilation
2. Verified `dist/` output structure and type declarations
3. Confirmed export paths work correctly
4. Validated library ready for workspace consumption

## Challenges & Solutions

### Challenge 1: Test Duplication

**Problem**: Tests running twice (once for .ts source, once for .js compiled)  
**Impact**: 210 tests instead of 105, confusing failure reports  
**Solution**: Created `vitest.config.ts` excluding `dist/` directory  
**Result**: Clean 105 test execution

### Challenge 2: Floating Point Precision

**Problem**: `calculateProjectedScore(50000, 10)` returned `55000.00000000001`  
**Initial Fix**: Changed `toBe(55000)` to `toBeCloseTo(55000, 5)`  
**Actual Solution**: JavaScript floating point arithmetic is imprecise; using
`toBeCloseTo()` is correct approach  
**Learning**: Always use `toBeCloseTo()` for floating point comparisons in tests

### Challenge 3: Year ID Parsing Bug

**Problem**: `parseInt('202A', 10)` returns `202` instead of `NaN`  
**Impact**: Invalid year IDs accepted without error  
**Root Cause**: `parseInt()` parses until it hits non-digit, then returns
partial result  
**Solution**: Added regex validation `/^\d+$/` before `parseInt()`  
**Code Change**:

```typescript
// Before
const year = parseInt(yearId, 10);

// After
if (!/^\d+$/.test(yearId)) {
  throw new Error(`Invalid year ID format: ${yearId}`);
}
const year = parseInt(yearId, 10);
```

### Challenge 4: TypeScript Build Including Tests

**Problem**: Initial `tsc` build tried to compile test files  
**Impact**: Build errors from test file structure  
**Solution**: Modified `tsconfig.json` to exclude tests directory  
**Result**: Clean compilation to `dist/` directory

## Validation Results

### Build Output

```
$ npm run build
> @angrybirdman/common@0.1.0 build
> tsc

[No errors - successful compilation]
```

**Output Structure**:

```
dist/
├── index.js
├── index.d.ts
├── constants/
│   ├── index.js
│   └── index.d.ts
├── types/
│   ├── index.js
│   └── index.d.ts
├── schemas/
│   ├── index.js
│   └── index.d.ts
└── utils/
    ├── index.js
    ├── index.d.ts
    ├── calculations.js
    ├── calculations.d.ts
    ├── date-formatting.js
    └── date-formatting.d.ts
```

### Test Results

```
$ npm test
 ✓ tests/date-formatting.test.ts (38)
 ✓ tests/calculations.test.ts (34)
 ✓ tests/schemas.test.ts (33)

 Test Files  3 passed (3)
      Tests  105 passed (105)
   Duration  670ms
```

### Type Checking

```
$ npm run type-check
> @angrybirdman/common@0.1.0 type-check
> tsc --noEmit

[No type errors]
```

## Files Created/Modified

### New Files (11 total)

1. `/common/src/constants/index.ts` - 127 lines
2. `/common/src/types/index.ts` - 398 lines
3. `/common/src/schemas/index.ts` - 531 lines
4. `/common/src/utils/calculations.ts` - 246 lines
5. `/common/src/utils/date-formatting.ts` - 281 lines
6. `/common/src/utils/index.ts` - 8 lines (re-exports)
7. `/common/src/index.ts` - 14 lines (main entry)
8. `/common/tests/calculations.test.ts` - 282 lines, 34 tests
9. `/common/tests/date-formatting.test.ts` - 348 lines, 38 tests
10. `/common/tests/schemas.test.ts` - 332 lines, 33 tests
11. `/common/vitest.config.ts` - 9 lines

### Modified Files (1 total)

1. `/common/tsconfig.json` - Excluded tests from compilation

**Total Lines of Code**: ~2,800 lines (excluding tests: ~1,600 lines)

## Library Usage Examples

### Importing Types

```typescript
import type {
  Clan,
  ClanBattle,
  CreateClanBattle,
} from '@angrybirdman/common/types';
```

### Using Validation Schemas

```typescript
import { clanBattleCreateSchema } from '@angrybirdman/common/schemas';

const result = clanBattleCreateSchema.safeParse(inputData);
if (!result.success) {
  console.error('Validation errors:', result.error);
}
```

### Performing Calculations

```typescript
import {
  calculateClanRatio,
  calculateBattleResult,
} from '@angrybirdman/common/utils';

const ratio = calculateClanRatio(500000, 5000); // Returns 1000 (displayed as "100.0")
const result = calculateBattleResult(500000, 450000); // Returns 1 (WIN)
```

### Generating Battle IDs

```typescript
import { generateBattleId, parseBattleId } from '@angrybirdman/common/utils';

const battleId = generateBattleId(new Date('2025-03-15')); // "20250315"
const date = parseBattleId('20250315'); // Date object
```

### Using Constants

```typescript
import {
  ACTION_CODES,
  BATTLE_RESULTS,
  MIN_FLOCK_POWER,
} from '@angrybirdman/common/constants';

if (actionCode === ACTION_CODES.KICK) {
  removeFromClan(player);
}
```

## Alignment with Specifications

### Data Model Alignment (Spec Section 6)

✅ All 11 Prisma entities have corresponding TypeScript types  
✅ Field types match Prisma schema exactly  
✅ Relationships preserved through foreign key fields  
✅ Optional fields marked correctly  
✅ Date fields consistently typed as `Date`

### Calculation Alignment (Spec Section 7)

✅ Battle result formula: Compare scores, return WIN/LOSS/TIE  
✅ Clan ratio: `(score / baselineFp) * 10`  
✅ Average ratio: `(score / totalFp) * 10`  
✅ Player ratio: `(score / fp) * 10`  
✅ Projected score: `score * (1 + nonplayingFpRatio/100)`  
✅ Margin ratio: `((score - opponentScore) / score) * 100`  
✅ FP margin: `((clanFp - opponentFp) / clanFp) * 100`  
✅ Nonplaying FP ratio: `((totalFp - playingFp - reserveFp) / totalFp) * 100`  
✅ Reserve FP ratio: `(reserveFp / totalFp) * 100`  
✅ Ratio ranking: Sort descending, assign ranks

## Next Steps

### Immediate (Step 3.3 - API Foundation)

1. Set up Fastify server with base configuration
2. Integrate Prisma Client for database access
3. Implement JWT authentication middleware (Keycloak integration)
4. Create error handling and logging utilities
5. Set up Swagger/OpenAPI documentation
6. Configure CORS, helmet, rate limiting

### Future Integration Points

1. **Frontend**: Will import types and schemas for form validation
2. **API**: Will use calculations for business logic endpoints
3. **Both**: Will use date utilities for ID generation/parsing
4. **Both**: Will reference constants for action codes and validation

## Lessons Learned

1. **Test Infrastructure First**: Creating `vitest.config.ts` should be done
   before writing tests to avoid duplicate execution issues

2. **parseInt() Gotcha**: Always validate string format before using
   `parseInt()` - it returns partial results for invalid input like '202A' → 202

3. **Floating Point Tests**: Use `toBeCloseTo()` for all floating point
   assertions to avoid precision issues

4. **Comprehensive Testing**: 105 tests may seem excessive, but they caught 2
   real bugs (year ID parsing, calculation expectations)

5. **Type-First Development**: Building types before implementation ensures
   consistency with schema and catches design issues early

6. **Modular Exports**: Subpath exports (`/types`, `/schemas`, `/utils`) enable
   tree-shaking and better IDE autocomplete

## Success Metrics

✅ **Completeness**: All 5 deliverables from implementation plan completed  
✅ **Type Safety**: 100% TypeScript with strict mode, no `any` types  
✅ **Test Coverage**: 105 tests, 100% pass rate  
✅ **Build Success**: Clean compilation with no errors or warnings  
✅ **Spec Alignment**: All formulas match specification exactly  
✅ **Code Quality**: Comprehensive documentation, clear naming, modular
structure  
✅ **Ready for Integration**: Library builds, exports correctly, ready for API
and frontend consumption

## Conclusion

Step 3.2 successfully established the common library foundation for the Angry
Birdman project. The `@angrybirdman/common` package now provides a robust,
type-safe, well-tested foundation for sharing code between frontend and backend
workspaces. All calculation formulas match the specification precisely,
validation schemas ensure data integrity, and comprehensive tests provide
confidence in the implementation.

The library is production-ready and serves as the shared contract between all
workspaces, eliminating code duplication and ensuring consistency across the
application.

---

**Implementation Status**: ✅ Complete  
**Ready for Step 3.3**: Yes  
**Blockers**: None
